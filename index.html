<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2Dカードゲーム - v23 + Phaser（v2.1仕様）</title>

  <!-- Phaser -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <!-- 外部CSS（v23デザイン） -->
  <link rel="stylesheet" href="https://tom-kido.github.io/cardgame/cardgame.css">
</head>
<body>
  <div class="game-board">
    <div class="background-pattern"></div>

    <!-- Phaser キャンバス -->
    <div id="phaser-root"></div>

    <!-- ▼▼▼ v23 DOM構造 ▼▼▼ -->

    <!-- プレイヤー1（下） -->
    <div class="player1-area">
      <!-- 山札 -->
      <div class="deck-stack player1" id="deckStackP1">
        <div class="deck-card deck-card-2 player1"></div>
        <div class="deck-card deck-card-1 player1"></div>
        <div class="deck-card deck-card-top player1 active" id="deckTopP1"><span>山札</span></div>
      </div>

      <!-- 場（5x2=10スロット） -->
      <div class="field-area player1" id="fieldAreaP1"></div>

      <!-- 右列（2スロット） -->
      <div class="right-column player1" id="rightColumnP1">
        <div class="right-slot" data-player="1" data-slot="0"></div>
        <div class="right-slot" data-player="1" data-slot="1"></div>
      </div>

      <!-- 手札 -->
      <div class="hand-area player1" id="handAreaP1">
        <div class="hand-label">あなたの手札</div>
        <div class="hand-cards"></div>
      </div>
    </div>

    <!-- プレイヤー2（上） -->
    <div class="player2-area">
      <div class="deck-stack player2" id="deckStackP2">
        <div class="deck-card deck-card-2 player2"></div>
        <div class="deck-card deck-card-1 player2"></div>
        <!-- CPUの山札トップに id を付与 -->
        <div class="deck-card deck-card-top player2" id="deckTopP2"><span>CPU<br>山札</span></div>
      </div>

      <div class="field-area player2" id="fieldAreaP2"></div>

      <div class="right-column player2" id="rightColumnP2">
        <div class="right-slot" data-player="2" data-slot="0"></div>
        <div class="right-slot" data-player="2" data-slot="1"></div>
      </div>

      <div class="hand-area player2" id="handAreaP2">
        <div class="hand-label">CPUの手札</div>
        <div class="hand-cards"></div>
      </div>
    </div>

    <!-- 共通UI -->
    <div class="deck-count player1" id="deckCountP1">P1: 10枚</div>
    <div class="deck-count player2" id="deckCountP2">CPU: 10枚</div>

    <div class="info-panel">
      <div style="font-size:18px;font-weight:bold;margin-bottom:5px;">2D カードゲーム</div>
      <div style="font-size:14px;color:#cbd5e1;">プレイヤー vs CPU</div>
    </div>

    <div class="turn-indicator" id="turnIndicator">あなたのターン</div>
    <button class="end-turn-btn" id="endTurnBtn">ターン終了</button>
    <div class="message-log" id="messageLog">ゲーム開始！あなたのターンです。山札をクリックしてカードを引いてください</div>
  </div>

  <script>
  // ========= 画像 =========
  const CARD_BACK_URL  = 'https://tom-kido.github.io/cardgame/card_back.png';
  const CARD_FRONT_URL = 'https://tom-kido.github.io/cardgame/card_front.png';

  // ========= DOMユーティリティ（nullセーフ） =========
  function getCenter(el) {
    if (!el) return { x: 0, y: 0 };
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  function centers(selector) {
    return Array.from(document.querySelectorAll(selector)).map(getCenter);
  }

  // フィールドのスロットを生成（5x2=10）
  function buildFieldSlots() {
    const p1 = document.getElementById('fieldAreaP1');
    const p2 = document.getElementById('fieldAreaP2');
    if (p1) p1.innerHTML = '';
    if (p2) p2.innerHTML = '';
    for (let i = 0; i < 10; i++) {
      const s1 = document.createElement('div');
      s1.className = 'field-slot';
      s1.dataset.player = '1';
      s1.dataset.slot = String(i);
      p1 && p1.appendChild(s1);

      const s2 = document.createElement('div');
      s2.className = 'field-slot';
      s2.dataset.player = '2';
      s2.dataset.slot = String(i);
      p2 && p2.appendChild(s2);
    }
  }

  // レイアウト計算（nullセーフ）
  function computeLayout() {
    // CPU山札トップ要素（id が無い場合のフォールバックも用意）
    const deckTopP2El = document.getElementById('deckTopP2')
      || document.querySelector('.deck-stack.player2 .deck-card-top');
    return {
      p1: {
        hand: getCenter(document.getElementById('handAreaP1')),
        fieldSlots: centers('#fieldAreaP1 .field-slot'),
        rightSlots: centers('#rightColumnP1 .right-slot'),
        deckTop: getCenter(document.getElementById('deckTopP1')),
      },
      p2: {
        hand: getCenter(document.getElementById('handAreaP2')),
        fieldSlots: centers('#fieldAreaP2 .field-slot'),
        rightSlots: centers('#rightColumnP2 .right-slot'),
        // CPU の山札座標を正しく参照
        deckTop: getCenter(deckTopP2El),
      }
    };
  }

  // 必要DOMが揃うまで待機
  function waitForLayoutReady() {
    return new Promise(resolve => {
      const ok = () =>
        document.getElementById('deckTopP1') &&
        document.getElementById('handAreaP1') &&
        document.querySelectorAll('#fieldAreaP1 .field-slot').length === 10 &&
        document.querySelectorAll('#fieldAreaP2 .field-slot').length === 10;

      const tick = () => (ok() ? resolve() : setTimeout(tick, 50));
      tick();
    });
  }

  class CardGameScene extends Phaser.Scene {
    constructor() { super('CardGame'); }

    preload() {
      this.load.image('cardBack',  CARD_BACK_URL);
      this.load.image('cardFront', CARD_FRONT_URL);
    }

    async create() {
      buildFieldSlots();
      await waitForLayoutReady();
      this.layout = computeLayout();

      this.snapRange = 40;
      this.currentPlayer = 1;
      this.players = {
        1: { deck: this.shuffle([1,2,3,4,5,6,7,8,9,10]), hand: [], field: Array(10).fill(null), right: [[],[]] },
        2: { deck: this.shuffle([1,2,3,4,5,6,7,8,9,10]), hand: [], field: Array(10).fill(null), right: [[],[]] }
      };

      this.cardsLayer = this.add.layer();

      const deckTopP1 = document.getElementById('deckTopP1');
      deckTopP1 && deckTopP1.addEventListener('click', () => this.drawCard(1));
      document.getElementById('endTurnBtn').addEventListener('click', () => this.endTurn());

      // DnD
      this.input.on('dragstart', (pointer, obj) => {
        // 右列はロック：ドラッグ開始させない
        if (obj.getData && obj.getData('locked')) return;
        this.children.bringToTop(obj);
      });
      this.input.on('drag', (pointer, obj, dragX, dragY) => {
        if (obj.getData && obj.getData('locked')) return;
        obj.x = dragX; obj.y = dragY; this.highlightNear(obj);
      });
      this.input.on('dragend', (pointer, obj) => {
        if (obj.getData && obj.getData('locked')) { this.clearHighlights(); return; }
        this.onDrop(obj);
      });

      this.updateDeckDisplays();
      this.message('ゲーム開始！あなたのターンです。山札をクリックしてカードを引いてください');
      this.hideTurnIndicatorLater();

      window.addEventListener('resize', () => {
        this.layout = computeLayout();
        this.layoutHands();
        this.layoutBoard();
      });

      this.layoutHands();
      this.layoutBoard();

      document.addEventListener('keydown', (e) => {
        if (this.currentPlayer !== 1) return;
        if (e.code === 'Space')  { e.preventDefault(); this.drawCard(1); }
        if (e.code === 'Enter')  { e.preventDefault(); this.endTurn(); }
      });
    }

    shuffle(a){ const b=[...a]; for(let i=b.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]]; } return b; }

    // --- カード生成（画像+番号テキストをContainerに） ---
    createCard(number, owner) {
      // 生成位置：owner によって p1/p2 の山札座標を切り替える
      const deckPos = owner === 1
        ? (this.layout?.p1.deckTop || { x: 0, y: 0 })
        : (this.layout?.p2.deckTop || { x: 0, y: 0 });
      const cont = this.add.container(deckPos.x, deckPos.y);
      const img  = this.add.image(0, 0, 'cardFront').setDisplaySize(80, 110);
      const txt  = this.add.text(0, 0, String(number), { fontFamily:'Segoe UI, sans-serif', fontSize:'28px', color:'#ffffff', fontStyle:'bold' }).setOrigin(0.5);
      cont.add([img, txt]);
      cont.setSize(80,110).setInteractive({ draggable:true });
      this.input.setDraggable(cont);
      cont.setData({ number, owner, source: 'hand', index: null, locked: false });
      this.cardsLayer.add(cont);
      return cont;
    }

    drawCard(player) {
      if (player !== this.currentPlayer && player === 1) { this.message('あなたのターンではありません'); return; }
      const p = this.players[player];
      if (!p || p.deck.length === 0) { this.message('山札にカードがありません'); return; }

      const num = p.deck.shift();
      const card = this.createCard(num, player);
      p.hand.push(card);

      const center = this.layout?.p1.hand || { x: 200, y: 500 };
      const idx = p.hand.length - 1;
      const tx = center.x + (idx - (p.hand.length-1)/2) * 20;
      const ty = center.y;
      this.tweens.add({ targets: card, x: tx, y: ty, duration: 400, ease: 'Power2' });
      this.updateDeckDisplays();
      this.message(`カード ${num} を手札に加えました`);
    }

    // --- ドロップ判定（手札→場、場→右列、場→場） ---
    onDrop(obj) {
      const owner = obj.getData('owner');
      if (owner !== 1) { this.clearHighlights(); return; } // P1のみ操作

      const source = obj.getData('source');
      const pt = { x: obj.x, y: obj.y };

      // 右列（常に優先して判定しても良い）
      if (source === 'field') {
        const moveRight = this.trySnapRight(obj, pt);
        if (moveRight) { this.clearHighlights(); return; }
        // 右列に入らなかったら、場→場 を試す
        const movedField = this.trySnapFieldFromField(obj, pt);
        if (movedField) { this.clearHighlights(); return; }
        // 戻す
        this.returnToField(obj);
        this.clearHighlights();
        return;
      }

      // 手札からの移動は場のみ
      if (source === 'hand') {
        const moved = this.trySnapFieldFromHand(obj, pt);
        if (!moved) this.returnToHand(obj);
        this.clearHighlights();
        return;
      }
    }

    trySnapFieldFromHand(obj, pt) {
      const slots = Array.from(document.querySelectorAll('#fieldAreaP1 .field-slot'));
      let best = { idx: -1, dist: Infinity, c: null };
      slots.forEach((slot, idx) => {
        const c = getCenter(slot);
        const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
        const occupied = !!this.cardsLayer.getChildren().find(o => o.name === `p1_field_${idx}`);
        if (d <= this.snapRange && !occupied && d < best.dist) best = { idx, dist: d, c };
      });
      if (best.idx !== -1) {
        // 手札→場
        this.players[1].hand = this.players[1].hand.filter(s => s !== obj);
        this.players[1].field[best.idx] = obj.getData('number');
        obj.setName(`p1_field_${best.idx}`);
        obj.setData('source', 'field');
        obj.setData('index', best.idx);
        this.tweens.add({ targets: obj, x: best.c.x, y: best.c.y, duration: 220, ease: 'Power2' });
        document.querySelectorAll('#fieldAreaP1 .field-slot')[best.idx]?.classList.add('occupied');
        this.layoutHands();
        this.message(`カード ${obj.getData('number')} を場へ配置`);
        return true;
      }
      return false;
    }

    trySnapFieldFromField(obj, pt) {
      const oldIdx = obj.getData('index');
      const slots = Array.from(document.querySelectorAll('#fieldAreaP1 .field-slot'));
      let best = { idx: -1, dist: Infinity, c: null };
      slots.forEach((slot, idx) => {
        if (idx === oldIdx) return; // 同じスロットは無視
        const c = getCenter(slot);
        const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
        const occupied = !!this.cardsLayer.getChildren().find(o => o.name === `p1_field_${idx}`);
        if (d <= this.snapRange && !occupied && d < best.dist) best = { idx, dist: d, c };
      });
      if (best.idx !== -1) {
        // 場→場
        this.players[1].field[oldIdx] = null;
        document.querySelectorAll('#fieldAreaP1 .field-slot')[oldIdx]?.classList.remove('occupied');
        this.players[1].field[best.idx] = obj.getData('number');
        obj.setName(`p1_field_${best.idx}`);
        obj.setData('index', best.idx);
        this.tweens.add({ targets: obj, x: best.c.x, y: best.c.y, duration: 220, ease: 'Power2' });
        document.querySelectorAll('#fieldAreaP1 .field-slot')[best.idx]?.classList.add('occupied');
        this.message(`カード ${obj.getData('number')} を場スロット ${oldIdx} → ${best.idx} に移動`);
        return true;
      }
      return false;
    }

    trySnapRight(obj, pt) {
      const rslots = Array.from(document.querySelectorAll('#rightColumnP1 .right-slot'));
      let best = { idx: -1, dist: Infinity, c: null };
      rslots.forEach((slot, idx) => {
        const c = getCenter(slot);
        const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
        if (d <= this.snapRange && d < best.dist) best = { idx, dist: d, c };
      });
      if (best.idx !== -1) {
        const old = obj.getData('index');
        this.players[1].field[old] = null;
        document.querySelectorAll('#fieldAreaP1 .field-slot')[old]?.classList.remove('occupied');
        const stack = this.players[1].right[best.idx];
        stack.push(obj);
        obj.setName('');
        obj.setData('source', 'right');
        obj.setData('locked', true); // 以降移動不可
        const offset = stack.length - 1;
        this.tweens.add({ targets: obj, x: best.c.x + offset*5, y: best.c.y + offset*20, duration: 220, ease: 'Power2' });
        this.message(`カード ${obj.getData('number')} を右列へ移動（ロック）`);
        return true;
      }
      return false;
    }

    returnToHand(obj) {
      const arr = this.players[1].hand;
      const center = this.layout?.p1.hand || { x: 200, y: 500 };
      const idx = arr.indexOf(obj);
      const tx = center.x + (idx - (arr.length-1)/2) * 20;
      const ty = center.y;
      this.tweens.add({ targets: obj, x: tx, y: ty, duration: 220, ease: 'Power2' });
      this.message('カードを手札に戻しました');
    }

    returnToField(obj) {
      const idx = obj.getData('index');
      const c = this.layout?.p1.fieldSlots[idx];
      if (c) this.tweens.add({ targets: obj, x: c.x, y: c.y, duration: 220, ease: 'Power2' });
      this.message('カードを元の場スロットに戻しました');
    }

    highlightNear(obj) {
      this.clearHighlights();
      const pt = { x: obj.x, y: obj.y };
      const source = obj.getData('source');

      if (source === 'hand') {
        // 手札→場のみ
        document.querySelectorAll('#fieldAreaP1 .field-slot').forEach((slot, idx) => {
          const c = getCenter(slot);
          const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
          const occupied = !!this.cardsLayer.getChildren().find(o => o.name === `p1_field_${idx}`);
          if (d <= this.snapRange && !occupied) slot.classList.add('highlight');
        });
      } else if (source === 'field') {
        // 場→右列 と 場→場
        document.querySelectorAll('#rightColumnP1 .right-slot').forEach(slot => {
          const c = getCenter(slot);
          const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
          if (d <= this.snapRange) slot.classList.add('highlight');
        });
        document.querySelectorAll('#fieldAreaP1 .field-slot').forEach((slot, idx) => {
          const c = getCenter(slot);
          const d = Phaser.Math.Distance.Between(pt.x, pt.y, c.x, c.y);
          const occupied = !!this.cardsLayer.getChildren().find(o => o.name === `p1_field_${idx}`);
          if (d <= this.snapRange && !occupied && idx !== obj.getData('index')) slot.classList.add('highlight');
        });
      }
    }
    clearHighlights() {
      document.querySelectorAll('.field-slot.highlight,.right-slot.highlight')
        .forEach(el => el.classList.remove('highlight'));
    }

    // --- レイアウト ---
    layoutHands() {
      const center = this.layout?.p1.hand; if (!center) return;
      const arr = this.players[1].hand;
      const overlap = 20;
      arr.forEach((card, i) => {
        const tx = center.x + (i - (arr.length-1)/2) * overlap;
        const ty = center.y;
        this.tweens.add({ targets: card, x: tx, y: ty, duration: 180, ease: 'Power2' });
      });

      const cpuCenter = this.layout?.p2.hand;
      this.players[2].hand.forEach((card, i) => {
        const tx = cpuCenter.x + (i - (this.players[2].hand.length-1)/2) * 10;
        const ty = cpuCenter.y;
        this.tweens.add({ targets: card, x: tx, y: ty, duration: 180, ease: 'Power2' });
      });
    }

    layoutBoard() {
      const p1Slots = this.layout?.p1.fieldSlots || [];
      this.players[1].field.forEach((num, idx) => {
        const c = this.cardsLayer.getChildren().find(o => o.name === `p1_field_${idx}`);
        if (c && p1Slots[idx]) this.tweens.add({ targets: c, x: p1Slots[idx].x, y: p1Slots[idx].y, duration: 180, ease: 'Power2' });
      });

      const p2Slots = this.layout?.p2.fieldSlots || [];
      this.players[2].field.forEach((num, idx) => {
        const c = this.cardsLayer.getChildren().find(o => o.name === `p2_field_${idx}`);
        if (c && p2Slots[idx]) this.tweens.add({ targets: c, x: p2Slots[idx].x, y: p2Slots[idx].y, duration: 180, ease: 'Power2' });
      });

      this.players[1].right.forEach((stack, sIdx) => {
        const base = this.layout?.p1.rightSlots[sIdx];
        stack.forEach((card, i) => { this.tweens.add({ targets: card, x: base.x + i*5, y: base.y + i*20, duration: 180, ease: 'Power2' }); });
      });
      this.players[2].right.forEach((stack, sIdx) => {
        const base = this.layout?.p2.rightSlots[sIdx];
        stack.forEach((card, i) => { this.tweens.add({ targets: card, x: base.x + i*5, y: base.y + i*20, duration: 180, ease: 'Power2' }); });
      });
    }

    // --- CPU＆UI（簡易） ---
    endTurn() {
      this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
      const ind = document.getElementById('turnIndicator');
      const btn = document.getElementById('endTurnBtn');
      if (this.currentPlayer === 1) {
        ind.textContent = 'あなたのターン';
        ind.style.background = 'linear-gradient(145deg, rgba(34,197,94,.9), rgba(22,163,74,.9))';
        btn.disabled = false; this.message('あなたのターンです');
      } else {
        ind.textContent = 'CPUのターン';
        ind.style.background = 'linear-gradient(145deg, rgba(239,68,68,.9), rgba(220,38,38,.9))';
        btn.disabled = true; this.message('CPUのターンです');
        this.cpuTurn();
      }
      ind.style.display = 'block'; this.hideTurnIndicatorLater();
    }
    cpuTurn() {
      this.time.delayedCall(800,  () => { if (this.players[2].deck.length>0) this.drawCard(2); });
      this.time.delayedCall(1600, () => { this.cpuPlayCard(); });
      this.time.delayedCall(2400, () => { this.endTurn(); });
    }
    cpuPlayCard() {
      const cpu = this.players[2];
      if (cpu.hand.length === 0) return;
      const empty = cpu.field.map((v,i)=>v===null?i:-1).filter(i=>i!==-1);
      if (empty.length === 0) return;
      const idxCard = Math.floor(Math.random()*cpu.hand.length);
      const idxSlot = empty[Math.floor(Math.random()*empty.length)];
      const card = cpu.hand.splice(idxCard,1)[0];
      cpu.field[idxSlot] = card.getData('number');
      card.setName(`p2_field_${idxSlot}`);
      card.setData('owner',2);
      card.setData('source','field');
      card.setData('index', idxSlot);
      // CPUカードは手札で裏、場に出す時点で表
      card.removeAll(true);
      const img  = this.add.image(0,0,'cardFront').setDisplaySize(80,110);
      const txt  = this.add.text(0,0,String(card.getData('number')), { fontFamily:'Segoe UI, sans-serif', fontSize:'28px', color:'#ffffff', fontStyle:'bold' }).setOrigin(0.5);
      card.add([img, txt]);
      const c = this.layout?.p2.fieldSlots[idxSlot];
      if (c) this.tweens.add({ targets: card, x: c.x, y: c.y, duration: 220, ease: 'Power2' });
      document.querySelector(`#fieldAreaP2 .field-slot[data-slot="${idxSlot}"]`)?.classList.add('occupied');
      this.message(`CPUがカード ${card.getData('number')} を場に配置しました`);
    }

    updateDeckDisplays() {
      document.getElementById('deckCountP1').textContent = `P1: ${this.players[1].deck.length}枚`;
      document.getElementById('deckCountP2').textContent = `CPU: ${this.players[2].deck.length}枚`;
      if (this.players[1].deck.length === 0) {
        const ds = document.getElementById('deckStackP1');
        const dt = document.getElementById('deckTopP1');
        if (ds) ds.style.opacity = '.3';
        if (dt) dt.style.pointerEvents = 'none';
      }
    }
    message(msg){ const log=document.getElementById('messageLog'); if(!log) return; log.textContent=msg; log.style.opacity='0'; setTimeout(()=>{ log.style.transition='opacity .25s ease'; log.style.opacity='1'; }, 30); }
    hideTurnIndicatorLater(){ setTimeout(()=>{ const el=document.getElementById('turnIndicator'); if(el) el.style.display='none'; }, 1800); }
  }

  // Phaser 起動
  const config = {
    type: Phaser.AUTO,
    parent: 'phaser-root',
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: 'rgba(0,0,0,0)',
    transparent: true,
    scene: [CardGameScene],
  };
  new Phaser.Game(config);
  </script>
</body>
</html>
